<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); </script>

# 智能体框架

<div align='center'>
<img src="../images/c2/比较.png" alt="比较" width="400">
</div>

[Autogen](#autogen)、[AgentScope](#AgentScope)、[CAMEL](#CAMEL)、[LangGraph](#langgraph)、[小结](#小结)

## AutoGen

<div align='center'>
<img src="../images/c2/autogen.png" alt="autogen" width="400">
</div>

开发者只需定义好每个团队成员的角色和发言顺序，剩下的协作流程便可由群聊机制自主驱动。

1. **框架结构**

清晰的分层和异步优先

* **分层设计**：
    * **autogen-core**：底层基础，封装语言模型交互、消息传递核心功能。
    * **autogen-agentchat**：提供用于开发对话式智能体应用的接口。
* **异步优先**：全面异步编程 **(async/await)**。网络请求是注意耗时操作，异步模式允许系统在等待一个智能体响应时处理其他任务，避免线程阻塞。

2. **核心智能体组件**

* **AssistantAgent**：任务的注意解决者，核心是封装了一个llm，职责是根据对话历史生成富有逻辑和知识的挥发，例如提出计划、编写代码。通过不同的system message，可赋予不同的专家角色

* **UserProxyAgent**：双重角色，既负责发起任务和传达意图，又可负责执行，如执行代码或调用工具，将结果反馈给其他智能体。

3. **Team**

* **RoundRobinGroupChat**（轮询群聊）：明确的、顺序化的对话协调之际，让参与的智能体按照预定义的顺序依次发言。适用于流程固定的任务，如软件开发。

* **工作流**
    1. 创建一个 RounRobinGroupChat 实例，并将所有参与协作的智能体加入其中。
    2. 当一个任务开始时，群聊会按照预设的顺序，依次激活相应的智能体。
    3. 被选中的智能体根据当前的对话上下文进行响应。
    4. 群聊将新的回复加入对话历史，并激活下一个智能体。
    5. 持续进行，直到达到最大对话轮次或预设的终止条件。


## AgentScope

工程化优先的智能体平台，内置了分布式部署、容错恢复、可观测性等企业级特性。

1. **分层架构**

<div align='center'>
<img src="../images/c2/agentscope.png" alt="agentscope" width="400">
</div>

* **Foundational Components**（基础组件层）：
    
    * Message组件定义统一的消息格式，文本、工具、多模态等
    * Memory组件提供短期和长期记忆管理
    * Model API层抽象了对不同llm和embedding的调用
    * Tool组件封装交互工具
* **Agent-level Infrastructure**（智能体基础设施）
    * Built-in Agents 预构建的智能体：浏览器使用智能体、深度研究智能体、
    * ReAct Paradigm：支持狗子，并行工具调用，状态管理，并且原生支持异步执行与实时控制 Async Execution and Real-time Steering
* **Multi-Agent Cooperation** (多智能体协作层)
    * MsgHub作为消息中心，负责智能体间的消息路由和状态管理
    * Pipeline系统则提供了灵活的工作流编排能力，支持顺序、并发等多种执行模式。
* **Deployment & Development** （开发与部署层）
    * AgentScope Runtime 提供生产级运行环境
    * AgentScope Studio 提供完整的可视化开发工具链

2. **消息驱动**

AgentScope的核心创新在于，消息驱动架构，所有的智能体交互都被抽象为消息的发送和接受。

将消息作为交互的基础单元，带来了几个关键优势。

* 异步解耦：消息的发送放和接受方在时间上解耦，无需相互等待。
* 位置透明：智能体无需关心另一个智能体在本地进程还是远程服务器，消息系统会自动处理路由。
* 可观测性：每一条消息都可以被记录、追踪和分析。
* 可靠性：消息可以被持久化存储和重试，即使系统出现故障，也能保证交互的最终一致性。



3. **智能体生命周期管理**

每个智能体有明确的生命周期（初始化、运行、暂停、销毁等），基于一个统一的基类 **AgentBase** 实现，。开发者通常只需关注核心的**reply**方法

4. **消息传递机制**

**消息中心（MsgHub）**，负责消息的路由和分发，还集成了持久化和分布式通信等高级功能。

* 灵活的消息路由：支持点对点、广播。组播等多种通信模式。
* 消息持久化：可以将消息自动保存到数据库（如SQLLite，MongoDB）
* 原生分布式支持：智能体可以被部署在不同的进程或服务器上，MsgHub通过**RPC**自动处理跨节点的通信。



## CAMEL

<div align='center'>
<img src="../images/c2/camel.png" alt="camel" width="400">
</div>

探索如何在最少的人类干预下，让俩个智能体通过“角色扮演”自主协作解决复杂任务，即自主协作：

1. **角色扮演**

一个任务通常由俩个智能体协作完成，一个扮演"**AI User**" ，负责提出需求、下达指令和构思任务步骤；另一个则扮演"**AI Assistant**",负责根据指令执行具体操作和提供解决方案。

2. **引导性提示**

在对话开始前，分别注入给俩个智能体一段精心设计的结构化的初始指令 system Prompt ,就像是为智能体植入的行动纲领，通常包括以下几个关键部分：

* **明确自身角色**
* **告知协作者角色**
* **定义共同目标**
* **设定行为约束和沟通协议**：最关键的一环，规定双方的行为，如要求双方需在回复的末尾使用特定标志如<SOLUTTION>标识任务的完成


## LangGraph

LangGraph 将智能体的执行流程建模为一种**状态机(State Machine)**，并将其表示为**有向图(Directed Graph)**。在这种范式中，图的节点(**Node**)代表一个具体的计算步骤（如调用LLM、执行工具），而**边(Edges)**则定义了从一个节点到另一个节点的跳转逻辑。这种设计天然支持循环，使得构建能够进行迭代、反思和自我修正的复杂智能体工作流变得简单。

三个基本构成要素：

1. **全局状态(state)**

整个图的执行过程围绕一个共享的状态对象进行，通常被定义为python的TypeDict，可以包含任何你需要追踪的信息，如对话历史、中间结果、迭代次数等。所有的节点都能读取和更新这个状态

2. **节点(Nodes)**

每个节点都是一个接收当前状态作为输入、并返回一个更新后的状态作为输出的python函数。节点时执行具体工作的单元。

3. **边(Edges)**

连接节点，定义工作流的方向。
* 常规边：指定一个节点的输出总是流向另一个固定的节点。
* **条件边**：通过一个函数判断当前的状态，动态的决定下一步应该跳转到那个节点。

## 小结

* **AutoGen** 将复杂的协作抽象为一场由多角色参与的、可自动进行的“群聊”，其核心在于“以对话驱动协作”。
* **AgentScope** 则着眼于工业级应用的健壮性与可扩展性，为构建高并发、分布式的多智能体系统提供了坚实的工程基础。
* **CAMEL** 以其轻量级的“角色扮演”和“引导性提示”范式，展示了如何用最少的代码激发两个专家智能体之间深度、自主的协作。
* **LangGraph** 则回归到更底层的“状态机”模型，通过显式的图结构赋予开发者对工作流的精确控制，尤其是其循环能力，为构建可反思、可修正的智能体铺平了道路。

通过对这些框架的深入分析，我们可以提炼出一个设计的权衡：**“涌现式协作”与“显式控制”**之间的选择。

AutoGen 和 CAMEL 更多地依赖于定义智能体的“角色”和“目标”，让复杂的协作行为从简单的对话规则中“涌现”出来，这种方式更贴近人类的交互模式，但有时难以预测和调试。

而 LangGraph 要求开发者明确地定义每一个步骤和跳转条件，牺牲了一部分“涌现”的惊喜，换来了高度的可靠性、可控性和可观测性。

同时，AgentScope 则揭示了第二个同样重要的维度：工程化。无论我们选择哪种协作范式，要将其从实验原型推向生产应用，都必须面对并发、容错、分布式部署等工程挑战。AgentScope 正是为解决这些问题而生，它代表了从“能运行”到“能稳定服务”的关键跨越。